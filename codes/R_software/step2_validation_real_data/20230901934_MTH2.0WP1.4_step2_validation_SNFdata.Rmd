---
title: 'Application of ConsensusOPLS package on SNF data.'
author: "Celine Bougel"
date: "`r format(Sys.time(), '%B %d, %Y')`"
bibliography: 20230901934_MTH2.0WP1.4_step2_validation_SNF.bib
biblio-style: apalike
link-citations: yes
nocite: '@*'
output:
  html_document:
    code_folding: show
    df_print: kable
    highlight: pygments
    number_sections: yes
    self_contained: yes
    theme: journal
    toc: yes
    toc_depth: 4
    toc_float:
      collapsed: true
      smooth_scroll: true
  editor_options:
    chunk_output_type: console
---

<style>
body {
text-align: justify}
</style>

\tableofcontents
\listoffigures
\listoftables
\newpage

# The Consensus OPLS method

The `ConsensusOPLS` R package implements the translated `Matlab` version of the 
**Consensus OPLS(-DA)** approach [@BOCCARD2013] (available at [Gitlab repository](https://gitlab.unige.ch/Julien.Boccard/consensusopls)), with the 
kernel-based reformulations of the **NIPALS** algorithm [@LINDGREN1993]. The 
kernel reformulation of the OPLS algorithm was proposed to extend its 
applicability to non-linear relationships. The `ConsensusOPLS` R package includes 
updated codes from the `KOPLS` R package: codes translated from the 
`Matlab` version  were then compared and corrected, if necessary, according to 
the package source codes [@BYLESJO2008] (available at [Github repository](https://github.com/sdechaumet/ramopls/tree/master/inst/package)).

The original method was improved during translation. Among other things, 
parallelisation have been implemented, mathematical formulas have been 
generalized for application to different practical cases, and a single function 
has been created so that the user can execute the entire method (with an option 
if he doesn't want to use permutation). 

The current package includes some quality metrics for the optimal model, as 
**R2**, **Q2**, **DQ2** [@WESTERHUIS2008], the permutation **diagnostics** 
[@SZYMANSKA2012], the computation of the **VIP values** [@WOLD2001], as 
well as many graphics (scores plot, block contributions, loading, permutations, 
etc.). [@WIGGER2021]





# Context

Once the functions have been implemented on R, the package was used to perform a 
discriminant analysis on the `demo_data` set proposed by Julien Boccard in his 
method. 

The aim now is to use the package on real public data and check that the matlab 
and R results remain consistent. This completes the validation of the method on 
real data. For this purpose, we have chosen the public and accessible data of 
Similarity Network Fusion (SNF) [@WANG2014] (available at 
[Website link](http://compbio.cs.toronto.edu/SNF/SNF/Software.html)).

Similarity Network Fusion (SNF) is a new computational method for data 
integration.  Briefly, SNF combines many different types of measurements (such 
as mRNA expression data, DNA methylation, miRNA expression and more - clinical 
data, questionnaires, image data, etc) for a given set of samples (e.g. 
patients). SNF first constructs a sample similarity network for each of the data
types and then iteratively integrates these networks using a novel network 
fusion method. Working in the sample network space allows SNF to avoid dealing 
with different scale, collection bias and noise in different data types. 
Integrating data in a non-linear fashion allows SNF to take advantage of the 
common as well as complementary information in different data types.

The authors generated 5 blocks of data: GBM, breast, colon, kidney and lung. For 
each one, gene expression, DNA methylation expression, miRNA expression, and 
survival data are available.

This analysis is not intended to be a comprehensive study of these data. We 
simply want to make sure, on real data, the the options offered by the package 
are functional. Since data with the SNF method has produced results, we hope 
that the ConsensusOPLS method will also provide results.





# R environment preparation

```{r setup, class.source='fold-hide'}
#install.packages("knitr")
library(knitr)
knitr::opts_chunk$set(echo = TRUE)

# To ensure repeatability
set.seed(12)
```

Before any action, it is necessary to verify that the needed packages are 
installed (the code chunks are not shown) and to define define the localisation
of the codes and the files.

```{r access}
path_data_brut <- "../../../data/data_brut/Wang2014_SNF" 
path_data_produced <- "../../../data/data_produced/R_software" 
path_results <- "../../../results" 
```

The code below has been designed to have as few dependencies as possible on R 
packages, except for the stable packages.

```{r packages_installation, class.source='fold-hide', warning=FALSE, include=FALSE, message=FALSE}
# install.packages(c("R.matlab", "ggplot2", "ggrepel", "stats", "utils",
#                    "devtools", "parallel", "SNFtool", "dplyr", "uwot",
#                    "readr", "SNFtool"))
# update.packages(ask = FALSE)
```

```{r packages_load, warning=FALSE, message=FALSE, class.source='fold-hide'}
library(R.matlab) # to read MATLAB data
library(ggplot2) # to make beautiful graphs
library(ggrepel) # to annotate ggplot2 graph
library(stats) # to use R statistical functions
library(utils) # to use R utility functions
library(devtools) # to import the ConsensusOPLS package
library(parallel) # to make some tasks in parallel
library(dplyr) # to use grammar of data manipulation
library(readr) # to import tsv files
library(SNFtool) # to use the standardNormalization function
```

We now install and load the `ConsensusOPLS` R package using:

```{r ConsensusOPLS_load, warning=FALSE, message=FALSE}
# Detaching and uninstalling a package
# detach("package:ConsensusOPLS", unload=T)
# remove.packages("ConsensusOPLS")

# Import check 17/05/2024
# devtools::install_github("sib-swiss/consensusOPLS/codes/ConsensusOPLS")
library(ConsensusOPLS)
```

Finally, we create a uniform theme that will be used for all graphic output.

```{r theme_ggplot2, class.source='fold-hide'}
theme_graphs <- theme_bw() + theme(strip.text = element_text(size=14),
                                   axis.title = element_text(size=16),
                                   axis.text = element_text(size=14),
                                   plot.title = element_text(size = 16),
                                   legend.title = element_text(size = 14))
```





# Import SNF data

Data can be imported directly by uploading the data you're interested in. 
However, an architecture similar to ours is required to execute the following 
code, i.e. a folder containing all the data, then **a folder for each type of** 
**cancer**, itself containing the 4 data files (`Gene_expression`, 
`Methy_Expression`, `Mirna_Expression` and `Survival`).

## Block names

For the following analysis, we have excluded two blocks of data: GBM and Colon, 
due to errors in the data (see comments below).

```{r data_blocs_names, class.source='fold-hide'}
# List of files and folders
cancer.types <- list.files(path_data_brut)
cancer.types

# Delete two blocks
# repeated TCGA-06-0147-01A-01T-0213-07 in GBM
# no cg* names in Methylation in Colon
cancer.types <- setdiff(cancer.types, c("GBM", "Colon")) 
cancer.types
```

## Number of blocks

Consequently, the number of blocks considered for analysis is:

```{r data_blocs_number}
nbrBlocs <- length(cancer.types)
nbrBlocs
```

## Collection structure

Now that we have a clear view of all the data blocks and files needed to build
the model, we can import them.

```{r import_datasets}
omics.cancer <- lapply(cancer.types, function(ct) {
  omics.files <- list.files(paste0(path_data_brut, "/", ct), full.names = T)
  omics <- mclapply(omics.files, mc.cores=1, function(x) {
    #print(x)
    if (grepl("Methy_Expression.txt$", x)) {
      tab <- read.delim(x, header=T, check.names = F, row.names=NULL)
      colnames(tab) <- colnames(tab)[-2]
      tab <- tab[, -ncol(tab)]
    } else {
      tab <- read.table(x, header=T, check.names = F, row.names=NULL)
    }

    if (!grepl("Survival.txt$", x)) {
      tab$row.names <- sub(" .+$|LLL[0-9]+$", "", tab$row.names)
      dup.names <- duplicated(tab$row.names)
      if (any(dup.names)) {
        tab <- tab[!dup.names,]
      }
      tab <- tab[!is.na(tab$row.names),]
      rownames(tab) <- tab$row.names
      tab <- tab[, -1]
      tab <- t(tab)
      # Attention: why does this step create subject 105 depending 1:104?
      #tab <- SNFtool::standardNormalization(tab)
    } else {
      rownames(tab) <- tab$PatientID
      tab <- tab[, -1]
    }
    rownames(tab) <- sub("-01[A-Z].+", "", rownames(tab))
    return (tab)
  })
  
  names(omics) <- gsub(pattern = paste0(toupper(ct),"_|.txt|_Expression"),
                       replacement = "", 
                       x = basename(omics.files))
  print(ct)
  print(all(sapply(omics, function(x) {
    all(rownames(x) == rownames(omics[[4]]))
  })))
  return (omics)
})
names(omics.cancer) <- cancer.types
```





# Data preprocessing

In this case, the data blocks don't have the same number of subjects. To use a 
horizontal data integration method such as ConsensusOPLS, it is necessary to work 
on the same subjects. A pre-processing of the data is necessary before proceeding.

## Reduce data set

```{r common_data, class.source='fold-hide'}
# Find the common column names across multiple data frames within the 
# omics.cancer list
common.genes <- Reduce(intersect, lapply(omics.cancer, function(x) colnames(x$Gene)))
common.methy <- Reduce(intersect, lapply(omics.cancer, function(x) colnames(x$Methy)))
common.mirna <- Reduce(intersect, lapply(omics.cancer, function(x) colnames(x$Mirna)))

# Build collection structure
omics.common <- invisible(lapply(c(names(omics.cancer), 'all'), function(ct) {
  if (ct != 'all') {
    omics <- omics.cancer[[ct]]
    omics <- lapply(omics, function(y) {
      rownames(y) <- sub('TCGA', ct, rownames(y))
      return (y)
    })
  } else {
    omics <- list(
      Gene=(do.call(rbind, lapply(names(omics.cancer), function(y) {
        tmp <- omics.cancer[[y]]$Gene[, common.genes]
        rownames(tmp) <- sub('TCGA', y, rownames(tmp))
        rownames(tmp) <- gsub(pattern = '-', replacement = ".", rownames(tmp))
        return (tmp)
      }))),
      Methy=(do.call(rbind, lapply(names(omics.cancer), function(y) {
        tmp <- omics.cancer[[y]]$Methy[, common.methy]
        rownames(tmp) <- sub('TCGA', y, rownames(tmp))
        rownames(tmp) <- gsub(pattern = '-', replacement = ".", rownames(tmp))
        return (tmp)
      }))),
      Mirna=(do.call(rbind, lapply(names(omics.cancer), function(y) {
        tmp <- omics.cancer[[y]]$Mirna[, common.mirna]
        rownames(tmp) <- sub('TCGA', y, rownames(tmp))
        rownames(tmp) <- gsub(pattern = '-', replacement = ".", rownames(tmp))
        return (tmp)
      }))),
      Survival=(do.call(rbind, lapply(names(omics.cancer), function(y) {
        tmp <- omics.cancer[[y]]$Survival
        rownames(tmp) <- sub('TCGA', y, rownames(tmp))
        rownames(tmp) <- gsub(pattern = '-', replacement = ".", rownames(tmp))
        return (tmp)
      })))
    )
  }
  return (omics)
}))
names(omics.common) <- c(names(omics.cancer), 'all')
```

Then we concatenate the common subjects according to data type (bloc type), 
using the row identifier as an indicator of the cancer type. So, for all common 
topics, we performed a vertical merge according to data block type.

```{r data2}
id2 <- !grepl('Kidney', rownames(omics.common[['all']][["Survival"]]))

omics.common.data2 <- lapply(omics.common[['all']][c('Gene', 'Methy', 'Mirna')], 
                             function(x) {x[id2,]})

names(omics.common.data2) <- c('Gene', 'Methy', 'Mirna')
```

```{r}
# # Select the 200 most variable
# omics.common.data2.200 <- lapply(omics.common.data2,
#                                  function(x) {
#                                    scale(x[,head(order(apply(x, 2, sd)), 200)])
#                                  })
# 
# omics.common.data2.300_s <- lapply(omics.common.data2,
#                                  function(x) {
#                                    scale(x[,head(order(apply(x, 2, sd)), 300)])
#                                  })
# 
# lapply(X = omics.common.data2.300_s,
#        function(bloc){
#          correlation_matrix_s <- cor(x = t(omics.common.data2.300_s[[1]]))
#          corrplot::corrplot(correlation_matrix_s, method = "circle"))})
# 
# 
# omics.common.data2.300_ns <- lapply(omics.common.data2,
#                                  function(x) {
#                                    x[,head(order(apply(x, 2, sd)), 300)]
#                                  })
# correlation_matrix_ns <- cor(omics.common.data2.300_ns)
# corrplot::corrplot(correlation_matrix_ns, method = "circle")
```


## Check dimension

To be on the safe side, let's make sure we have the same subjects in each block.

```{r check_dim, class.source='fold-hide'}
# Check dimension
dims <- lapply(X = 1:length(omics.common.data2),
               FUN = function(X){
                 dim(omics.common.data2[[X]])})
names(dims) <- names(omics.common.data2)
dims

# Remove unuseful object for the next steps
rm(dims)
```

## Check rank

```{r check_rank, class.source='fold-hide'}
library(Matrix)
# Check rank
ranks_all <- lapply(X = 1:length(omics.common.data2),
               FUN = function(X){
                 rankMatrix(omics.common.data2[[X]])})
names(ranks_all) <- names(omics.common.data2)
ranks_all

# Remove unuseful object for the next steps
rm(ranks_all)
```

## Add Y response

We also import the response variable Y:

```{r finishing_collection}
# Add response matrix
Y <- rownames(omics.common[['all']][["Survival"]][id2,])
Y <- gsub("\\.", "-", Y) # restaure original name
Y <- Y %>% sub("-.+", "", .) # select only cancer type

summary(as.factor(Y))
```

And the sample names:

```{r sample_names}
Sample_names <- rownames(omics.common[['all']][["Survival"]][id2,])
```


# Export data

## For R

Now we export the results in a format that can be recognized and used by R.

```{r save_RDS}
# base::save(omics.cancer, 
#            file = file.path(path_data_produced, "data_SNF.RData"))
# 
# base::save(omics.common.data2, 
#            file = file.path(path_data_produced, "data_SNF_common.RData"))
``` 

## For Matlab

Now we export the results in a format that can be recognized and used by Matlab.

```{r save_results, class.source='fold-hide'}
# common_pattern <- "20230901934_step2_validation_data_SNF_common_"
# R.matlab::writeMat(data_SNF = omics.common.data2,
#                    con = file.path(path_data_produced,
#                                    paste0(common_pattern,
#                                           "collection.mat")))
# 
# T1<-Sys.time()
# R.matlab::writeMat(data_SNF_VarNames = lapply(X = omics.common.data2,
#                                               FUN = function(X) colnames(X)),
#                    con = file.path(path_data_produced,
#                                    paste0(common_pattern,
#                                           "VarNames.mat")))
# T2<-Sys.time()
# Tdiff <- T2 - T1
# Tdiff #Time difference of 46.02359 mins
# 
# R.matlab::writeMat(Y = Y,
#                    con = file.path(path_data_produced,
#                                    paste0(common_pattern, "Y_factor.mat")))
# R.matlab::writeMat(SampleNames = Sample_names,
#                    con = file.path(path_data_produced,
#                                    paste0(common_pattern, "SampleNames.mat")))
```


# Linear kernel 

To prepare the data for the Consensus model, certain method parameters must be 
defined.

```{r define_cv_parameters}
# Number of predictive component(s)
LVsPred <- 1

# Maximum number of orthogonal components
LVsOrtho <- 1

# Number of cross-validation folds
CVfolds <- 211
CVfolds
```

## ConsensusOPLS-DA model

```{r run_model_da}
rvcopls <- ConsensusOPLS::ConsensusOPLS(data = omics.common.data2,
                                        Y=factor(Y),
                                        maxPcomp = LVsPred,
                                        maxOcomp  = LVsOrtho,
                                        modelType = "da",
                                        nperm = 2,
                                        cvType = "nfold",
                                        nfold = CVfolds,
                                        kernelParams =
                                          list(type = "p",
                                               params = c(order = 1)),
                                        mc.cores = 1,
                                        verbose = TRUE)
```

```{r results_mod}
# pca <- prcomp(omics.common.data2[[3]])
# plot(pca$x[,c(1,2)], col=c(2:3)[factor(sub("-.+", "", rownames(omics.common[['all']][["Survival"]][id2,])))])
# umapres <- uwot::umap(omics.common.data2[[2]])
# plot(umapres, col=c(2:3)[factor(sub("-.+", "", rownames(omics.common[['all']][["Survival"]][id2,])))])
```

### Checks

We import all the Matlab results generated to compare them automatically.

```{r PrometIs_define_path}
path_data_test <- "Matlab_results/"
common_name <- "20230901934_SNF_"
common_RV <- "RVConsensusOPLS_"
common_CV <- "ConsensusOPLSCV_"
```

```{r SNF_RVConsensusOPLS_outputs}
# ----- RVConsensusOPLS
## normKernels = Amat in matlab
# Relative
# for(i in 1:length(nbrBlocs)){
#   matlab <- as.matrix(read.table(
#     file = paste0(path_data_test, common_name,
#                   common_RV, "02_Amat_", i, ".txt"),
#     header = TRUE, sep = "\t", dec = ".", row.names = 1))
#   R_res <- rvcopls$optimal$modelCV$normKernels[[i]]
#   relative_compare <- (matlab - R_res) / max(1, R_res)
#   
#   matrix_compare <- matrix(0, ncol = ncol(relative_compare),
#                            nrow = nrow(relative_compare))
#   colnames(matrix_compare) = colnames(relative_compare)
#   rownames(matrix_compare) = rownames(relative_compare)
#   testthat::expect_equal(relative_compare,
#                          matrix_compare, tolerance=1e-3)
# }
# Absolute
# for(i in 1:length(nbrBlocs)){
#   testthat::expect_equal(as.matrix(read.table(
#     file = paste0(path_data_test, common_name,
#                   common_RV, "02_Amat_", i, ".txt"),
#     header = TRUE, sep = "\t", dec = ".", row.names = 1)),
#     rvcopls$optimal$modelCV$normKernels[[i]], tolerance=1e-3)
# }



## RV
# Relative
# matlab <- as.matrix(read.table(
#   file = paste0(path_data_test, common_name, common_RV, "01_RV.txt"),
#   header = TRUE, sep = "\t", dec = "."))[1,]
# R_res <- rvcopls$optimal$modelCV$RV
# relative_compare <- (matlab - R_res)/ max(1, R_res)
# matrix_compare <- rep(0, length(relative_compare))
# names(matrix_compare) <- names(relative_compare)
# testthat::expect_equal(relative_compare,
#                        matrix_compare, tolerance=1e-3)
# Absolute
# testthat::expect_equal(as.matrix(read.table(
#   file = paste0(path_data_test, common_name, common_RV, "01_RV.txt"),
#   header = TRUE, sep = "\t", dec = "."))[1,],
#   rvcopls$optimal$modelCV$RV, tolerance=1e-6)



## lambda = lambda_raw in matlab
# Relative
# matlab <- as.matrix(read.table(
#   file = paste0(path_data_test, common_name, common_RV, "04_lambdaRaw.txt"),
#   header = TRUE, sep = "\t", dec = ".", row.names = 1))
# R_res <- rvcopls$optimal$modelCV$Model$lambda
# relative_compare <- (matlab - R_res)/ max(1, R_res)
# matrix_compare <- matrix(0, ncol = ncol(relative_compare),
#                          nrow = nrow(relative_compare))
# colnames(matrix_compare) = colnames(relative_compare)
# rownames(matrix_compare) = rownames(relative_compare)
# testthat::expect_equal(relative_compare,
#                        matrix_compare, tolerance=1e-3)
# Absolute
# testthat::expect_equal(as.matrix(read.table(
#   file = paste0(path_data_test, common_name, common_RV, "04_lambdaRaw.txt"),
#   header = TRUE, sep = "\t", dec = ".", row.names = 1)),
#   rvcopls$optimal$modelCV$Model$lambda, tolerance=1e-6)



## blockContribution = lambda in matlab
# Relative
matlab <- as.matrix(read.table(
  file = paste0(path_data_test, common_name, common_RV, "05_lambda.txt"),
  header = TRUE, sep = "\t", dec = ".", row.names = 1))
R_res <- rvcopls@blockContribution
relative_compare <- (matlab - R_res)/ max(1, R_res)
matrix_compare <- matrix(0, ncol = ncol(relative_compare),
                         nrow = nrow(relative_compare))
colnames(matrix_compare) = colnames(relative_compare)
rownames(matrix_compare) = rownames(relative_compare)
testthat::expect_equal(relative_compare,
                       matrix_compare, tolerance=1e-3)
# Absolute
# testthat::expect_equal(matlab, R_res, tolerance=1e-6)



## loadings
for(i in 1:length(nbrBlocs)){
  loading_R <- rvcopls@loadings[[1]]
  rownames(loading_R) <- NULL
  loadings_matlab <- as.matrix(read.table(
    file = paste0(path_data_test, common_name,
                  common_RV, "06_loadings_", i, ".txt"),
    header = TRUE, sep = "\t", dec = "."))
  loadings_tot <- (loadings_matlab - loading_R) / 
    apply(abs(loading_R), c(1,2), max, 1)
  matrix_compare <- matrix(0, nrow = nrow(loadings_tot), 
                           ncol=ncol(loadings_tot))
  colnames(matrix_compare) <- colnames(loadings_tot)
  testthat::expect_equal(loadings_tot, 
                         matrix_compare, tolerance=1e-3)
}
# Absolute
# for(i in 1:length(nbrBlocs)){
#   loading_R <- rvcopls@loadings[[1]]
#   rownames(loading_R) <- NULL
#   testthat::expect_equal(as.matrix(read.table(
#     file = paste0(path_data_test, common_name, 
#                   common_RV, "06_loadings_", i, ".txt"), 
#     header = TRUE, sep = "\t", dec = ".")), 
#     loading_R, tolerance=1e-6)
# }
```

```{r SNF_optimal_model_ConsensusOPLSCV_outputs}
# ----- RVConsensusOPLS => ConsensusOPLSCV: optimal model
## Cp
# Relatives
# Cp_matlab <- as.matrix(read.table(file = paste0(path_data_test, common_name,
#                                                 common_CV, "01_Cp.txt"),
#                                   header = FALSE, sep = ",", dec = "."))
# colnames(Cp_matlab) <- NULL
# rownames(Cp_matlab) <- c("1", "2")
# Cp_R <- rvcopls$optimal$modelCV$Model$Cp
# relative_compare <- (Cp_matlab - Cp_R)/ max(1, Cp_R)
# matrix_compare <- matrix(0, ncol = ncol(relative_compare),
#                          nrow = nrow(relative_compare))
# colnames(matrix_compare) = colnames(relative_compare)
# rownames(matrix_compare) = rownames(relative_compare)
# testthat::expect_equal(relative_compare,
#                        matrix_compare, tolerance=1e-3)
# Absolute
# testthat::expect_equal(Cp_matlab,
#                        rvcopls$optimal$modelCV$Model$Cp,
#                        tolerance=1e-6)



## Sp
# Relatives
# matlab <- as.numeric(read.table(
#   file = paste0(path_data_test, common_name, common_CV, "02_Sp.txt"),
#   header = FALSE, sep = ",", dec = "."))
# R_res <- rvcopls$optimal$modelCV$Model$Sp[1,1]
# relative_compare <- (matlab - R_res)/ max(1, R_res)
# testthat::expect_equal(relative_compare,
#                        0, tolerance=1e-3)
# Absolute
# testthat::expect_equal(as.numeric(read.table(
#   file = paste0(path_data_test, common_name, common_CV, "02_Sp.txt"),
#   header = FALSE, sep = ",", dec = ".")),
#   rvcopls$optimal$modelCV$Model$Sp[1,1], tolerance=1e-6)



## Up
# Relatives
# Up_matlab <- as.matrix(read.table(file = paste0(path_data_test, common_name,
#                                                 common_CV, "03_Up.txt"),
#                                   header = FALSE, sep = ",", dec = "."))
# dimnames(Up_matlab) <- NULL
# Up_R <- rvcopls$optimal$modelCV$Model$Up
# relative_compare <- (Up_matlab - Up_R)/ max(1, Up_R)
# matrix_compare <- matrix(0, ncol = ncol(relative_compare),
#                          nrow = nrow(relative_compare))
# colnames(matrix_compare) = colnames(relative_compare)
# rownames(matrix_compare) = rownames(relative_compare)
# testthat::expect_equal(relative_compare,
#                        matrix_compare, tolerance=1e-3)
# Absolute
# testthat::expect_equal(Up_matlab,
#                        rvcopls$optimal$modelCV$Model$Up,
#                        tolerance=1e-6)



## AllYhat
# Relatives
matlab <- as.matrix(read.table(
  file = paste0(path_data_test, common_name, common_CV, "04_AllYhat.txt"),
  header = TRUE, sep = "\t", dec = ".", row.names = 1))
colnames(matlab) <- gsub(pattern = "X", replacement = "", 
                                 x = colnames(matlab), fixed = TRUE)
R_res <- rvcopls@cv$AllYhat
relative_compare <- (matlab - R_res)/ max(1, R_res)
matrix_compare <- matrix(0, ncol = ncol(relative_compare),
                         nrow = nrow(relative_compare))
colnames(matrix_compare) = colnames(relative_compare)
rownames(matrix_compare) = rownames(relative_compare)
testthat::expect_equal(relative_compare,
                       matrix_compare, tolerance=1e-3)
# Absolute
# testthat::expect_equal(matlab, R_res, tolerance=1e-6)



## Q2Yhat
# Relatives
matlab <- as.numeric(as.matrix(read.table(
  file = paste0(path_data_test, common_name, common_CV, "05_Q2Yhat.txt"),
  header = FALSE, sep = ",", dec = ".")))
R_res <- rvcopls@Q2
relative_compare <- (matlab - R_res)/ max(1, R_res)
matrix_compare <- rep(0, length(relative_compare))
names(matrix_compare) = names(relative_compare)
testthat::expect_equal(relative_compare,
                       matrix_compare, tolerance=1e-3)
# Absolute
# testthat::expect_equal(matlab, unname(R_res), tolerance=1e-6)



## DQ2Yhat
# Relatives
matlab <- as.numeric(as.matrix(read.table(
  file = paste0(path_data_test, common_name, common_CV, "06_DQ2Yhat.txt"),
  header = FALSE, sep = ",", dec = ".")))
R_res <- rvcopls@DQ2
relative_compare <- (matlab - R_res)/ max(1, R_res)
matrix_compare <- rep(0, length(relative_compare))
names(matrix_compare) = names(relative_compare)
testthat::expect_equal(relative_compare,
                       matrix_compare, tolerance=1e-3)
# Absolute
# testthat::expect_equal(matlab, unname(R_res), tolerance=1e-6)



## Tp
# Relatives
# for(i in 1:length(nbrBlocs)){
#   Tp_matlab <- read.table(file = paste0(path_data_test, common_name,
#                                         common_CV, "07_Tp_", i, ".txt"),
#                           header = TRUE, sep = "\t", dec = ".", row.names = 1)
#   if (i == 1){colnames(Tp_matlab) <- NULL
#   } else{colnames(Tp_matlab) <- "p_1"}
#   TP_R <- rvcopls$optimal$modelCV$Model$Tp[[i]]
#   relative_compare <- (as.matrix(Tp_matlab) - TP_R) / 
#     apply(abs(TP_R), c(1,2), max, 1)
#   matrix_compare <- matrix(0, nrow = nrow(relative_compare), 
#                            ncol=ncol(relative_compare))
#   colnames(matrix_compare) <- colnames(relative_compare)
#   rownames(matrix_compare) <- rownames(relative_compare)
#   testthat::expect_equal(relative_compare, 
#                          matrix_compare, tolerance=1e-3)
# }
# Absolute
# for(i in 1:2){
#   Tp_matlab <- read.table(file = paste0(path_data_test, common_name, 
#                                         common_CV, "07_Tp_", i, ".txt"), 
#                           header = TRUE, sep = "\t", dec = ".", row.names = 1)
#   if (i == 1){colnames(Tp_matlab) <- NULL
#   } else{colnames(Tp_matlab) <- "p_1"}
#   testthat::expect_equal(as.matrix(Tp_matlab), 
#                          rvcopls$optimal$modelCV$Model$Tp[[i]], 
#                          tolerance=1e-6)
# }



## scores = [T To] in matlab
# Relatives
matlab <- read.table(file =
                       paste0(path_data_test, common_name,
                              common_CV, "08_scores.txt"),
                     header = TRUE, sep = "\t", dec = ".",
                     row.names = 1)
R_res <- rvcopls@scores
relative_compare <- (matlab - R_res)/ apply(abs(R_res), c(1,2), max, 1)
relative_compare <- as.matrix(relative_compare)
matrix_compare <- matrix(0, ncol = ncol(relative_compare),
                         nrow = nrow(relative_compare))
colnames(matrix_compare) = colnames(relative_compare)
rownames(matrix_compare) = rownames(relative_compare)
testthat::expect_equal(relative_compare,
                       matrix_compare, tolerance=1e-3)
# Absolute
# testthat::expect_equal(as.matrix(matlab), R_res, tolerance=1e-6)
``` 


### Conclusion

We find that the results obtained between Matlab and R are identical, with an 
error tolerance of 1e-6.

The package had already been validated on a demonstration set. It had also been 
validated on 2 internal project data sets (data not accessible or published at 
the time of testing). The present test validates the results provided, on a real 
data set. The user can reproduce the results with the codes provided.

### Main results of the model DA

```{r print_main_results_R2, class.source='fold-hide'}
position <- rvcopls@cv$nOcompOpt

paste0('R2: ', round(rvcopls@R2Y[position], 4))
```

```{r print_main_results_Q2, class.source='fold-hide'}
paste0('Q2: ', round(rvcopls@Q2[position], 4))
```

```{r print_main_results_DQ2, class.source='fold-hide'}
paste0('DQ2: ', round(rvcopls@DQ2[position], 4))
```

```{r ggplot_score_data, class.source='fold-hide', warning=FALSE}
ggplot2::ggplot(data = data.frame(
  "p_1" = rvcopls@scores[, "p_1"],
  "o_1" = rvcopls@scores[, "o_1"],
  "Labs" = as.matrix(base::unlist(rownames(omics.common.data2$Gene))),
  "Factor" = gsub(pattern = "\\..*",
                  replacement = "",
                  x = rownames(omics.common.data2$Gene))
  ),
                aes(x = p_1, y = o_1, label = Labs,
                    shape = Factor, colour = Factor)) +
  ggplot2::xlab("Predictive component") +
  ggplot2::ylab("Orthogonal component") +
  ggplot2::ggtitle("ConsensusOPLS Score plot")+
  ggplot2::geom_point(size = 2.5) +
  ggrepel::geom_text_repel(size = 4, show.legend = FALSE) +
  theme_graphs+
  ggplot2::scale_color_manual(values = c("#7F3C8D", "#11A579"))
```

## ConsensusOPLS-reg log model

```{r run_model_reg}
rvcopls.reg <- ConsensusOPLS:::ConsensusOPLS(data = omics.common.data2,
                                             Y=factor(Y),
                                             maxPcomp = LVsPred,
                                             maxOcomp  = LVsOrtho,
                                             modelType = "reg",
                                             nperm = 2,
                                             cvType = "nfold",
                                             nfold = CVfolds, 
                                             kernelParams = 
                                               list(type = "p", 
                                                    params = c(order = 1)),
                                             mc.cores = 1,
                                             verbose = TRUE)
```

```{r print_main2_results_R2, class.source='fold-hide'}
position <- rvcopls.reg@cv$nOcompOpt

paste0('R2: ', round(rvcopls.reg@R2Y[position], 4))
```

```{r print_main2_results_Q2, class.source='fold-hide'}
paste0('Q2: ', round(rvcopls@Q2[position], 4))
```

```{r ggplot2_score_data, class.source='fold-hide', warning=FALSE}
ggplot2::ggplot(data = data.frame(
  "p_1" = rvcopls.reg@scores[, "p_1"],
  "o_1" = rvcopls.reg@scores[, "o_1"],
  "Labs" = as.matrix(base::unlist(rownames(omics.common.data2$Gene))),
  "Factor" = gsub(pattern = "\\..*",
                  replacement = "",
                  x = rownames(omics.common.data2$Gene))
  ),
                aes(x = p_1, y = o_1, label = Labs,
                    shape = Factor, colour = Factor)) +
  ggplot2::xlab("Predictive component") +
  ggplot2::ylab("Orthogonal component") +
  ggplot2::ggtitle("ConsensusOPLS Score plot")+
  ggplot2::geom_point(size = 2.5) +
  ggrepel::geom_text_repel(size = 4, show.legend = FALSE) +
  theme_graphs+
  ggplot2::scale_color_manual(values = c("#7F3C8D", "#11A579"))
```


# Non linear kernel
## ConsensusOPLS-DA model

```{r run_model_da_kernel2}
rvcopls <- ConsensusOPLS:::ConsensusOPLS(data = omics.common.data2,
                                         Y=factor(Y),
                                         maxPcomp = LVsPred,
                                         maxOcomp  = LVsOrtho,
                                         modelType = "da",
                                         nperm = 2,
                                         cvType = "nfold",
                                         nfold = CVfolds,
                                         kernelParams = 
                                           list(type = "p", 
                                                params = c(order = 2)),
                                         mc.cores = 1,
                                         verbose = TRUE)
```

```{r print_main_results_R2_kernel2, class.source='fold-hide'}
position <- rvcopls@cv$nOcompOpt

paste0('R2: ', round(rvcopls@R2Y[position], 4))
```

```{r print_main_results_Q2_kernel2, class.source='fold-hide'}
paste0('Q2: ', round(rvcopls@Q2[position], 4))
```

```{r print_main_results_DQ2_kernel2, class.source='fold-hide'}
paste0('DQ2: ', round(rvcopls@DQ2[position], 4))
```

```{r ggplot_score_data_kernel2, class.source='fold-hide', warning=FALSE}
ggplot2::ggplot(data = data.frame(
  "p_1" = rvcopls@scores[, "p_1"],
  "o_1" = rvcopls@scores[, "o_1"],
  "Labs" = as.matrix(base::unlist(rownames(omics.common.data2$Gene))),
  "Factor" = gsub(pattern = "\\..*",
                  replacement = "",
                  x = rownames(omics.common.data2$Gene))
  ),
                aes(x = p_1, y = o_1, label = Labs,
                    shape = Factor, colour = Factor)) +
  ggplot2::xlab("Predictive component") +
  ggplot2::ylab("Orthogonal component") +
  ggplot2::ggtitle("ConsensusOPLS Score plot")+
  ggplot2::geom_point(size = 2.5) +
  ggrepel::geom_text_repel(size = 4, show.legend = FALSE) +
  theme_graphs+
  ggplot2::scale_color_manual(values = c("#7F3C8D", "#11A579"))
```

```{r}
data_two_plots <- data.frame("Values" = rvcopls@blockContribution[, "p_1"],
                             "Type" = "Pred",
                             "Blocks" = labels(omics.common.data2))
data_two_plots <- data.frame("Values" = c(data_two_plots$Values,
                                          rvcopls@blockContribution[, "o_1"]),
                             "Type" = c(data_two_plots$Type,
                                        rep("Ortho", times = length(rvcopls@blockContribution[, "o_1"]))),
                             "Blocks" = c(data_two_plots$Blocks,
                                          labels(omics.common.data2)))

ggplot(data = data_two_plots,
       aes(x = factor(Type), 
           y = Values, 
           fill = factor(Type))) +
  geom_bar(stat = 'identity') + 
  ggtitle("Block contributions to each component")+
  geom_text(aes(label=round(Values, 2)), vjust=-0.3) +
  xlab("Data blocks") +
  ylab("Weight") +
  facet_wrap(. ~ Blocks)+
  theme_graphs+
  scale_fill_discrete(name = "Component")+
  scale_fill_manual(values = c("#7F3C8D", "#11A579"))

ggplot(data = data_two_plots,
                           aes(x = Blocks, 
                               y = Values, 
                               fill = Blocks)) +
    geom_bar(stat = 'identity') +
    geom_text(aes(label=round(Values, 2)), vjust=-0.3) +
    ggtitle("Block contributions to each component") +
    xlab("Components") +
    ylab("Weight") +
    facet_wrap(. ~ factor(Type)) +
    theme_graphs +
    theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1),
          plot.title = element_text(hjust = 0.5, 
                                    margin = margin(t = 5, r = 0, b = 0, l = 100))) +
    scale_fill_manual(values = c("#1B9E77", "#D95F02", "#7570B3"))
```


## ConsensusOPLS-reg log model

```{r run_model_reg_kernel2}
rvcopls.reg <- ConsensusOPLS:::ConsensusOPLS(data = omics.common.data2,
                                             Y=factor(Y),
                                             maxPcomp = LVsPred,
                                             maxOcomp  = LVsOrtho,
                                             modelType = "reg",
                                             nperm = 2,
                                             cvType = "nfold",
                                             nfold = CVfolds, 
                                             kernelParams = 
                                               list(type = "p", 
                                                    params = c(order = 2)),
                                             mc.cores = 1,
                                             verbose = TRUE)
```


```{r print_main2_results_R2_kernel2, class.source='fold-hide'}
position <- rvcopls.reg@cv$nOcompOpt

paste0('R2: ', round(rvcopls.reg@R2Y[position], 4))
```

```{r print_main2_results_Q2_kernel2, class.source='fold-hide'}
paste0('Q2: ', round(rvcopls.reg@Q2[position], 4))
```

```{r ggplot2_score_data_kernel2, class.source='fold-hide', warning=FALSE}
ggplot2::ggplot(data = data.frame(
  "p_1" = rvcopls.reg@scores[, "p_1"],
  "o_1" = rvcopls.reg@scores[, "o_1"],
  "Labs" = as.matrix(base::unlist(rownames(omics.common.data2$Gene))),
  "Factor" = gsub(pattern = "\\..*",
                  replacement = "",
                  x = rownames(omics.common.data2$Gene))
  ),
                aes(x = p_1, y = o_1, label = Labs,
                    shape = Factor, colour = Factor)) +
  ggplot2::xlab("Predictive component") +
  ggplot2::ylab("Orthogonal component") +
  ggplot2::ggtitle("ConsensusOPLS Score plot")+
  ggplot2::geom_point(size = 2.5) +
  ggrepel::geom_text_repel(size = 4, show.legend = FALSE) +
  theme_graphs+
  ggplot2::scale_color_manual(values = c("#7F3C8D", "#11A579"))
```

```{r}
data_two_plots <- data.frame("Values" = rvcopls.reg@blockContribution[, "p_1"],
                             "Type" = "Pred",
                             "Blocks" = labels(omics.common.data2))
data_two_plots <- data.frame("Values" = c(data_two_plots$Values,
                                          rvcopls.reg@blockContribution[, "o_1"]),
                             "Type" = c(data_two_plots$Type,
                                        rep("Ortho", times = length(rvcopls.reg@blockContribution[, "o_1"]))),
                             "Blocks" = c(data_two_plots$Blocks,
                                          labels(omics.common.data2)))
omics.colors <- c("#E41A1C", "#377EB8", "#4DAF4A")
ggplot(data = data_two_plots,
       aes(x = Blocks, 
           y = Values, 
           fill = Blocks)) +
  geom_bar(stat = 'identity') +
  geom_text(aes(label=round(Values, 2)), vjust=-0.3) +
  ggtitle("Block contributions to each component") +
  xlab("Components") +
  ylab("Weight") +
  facet_wrap(. ~ factor(Type)) +
  theme_graphs +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1),
        plot.title = element_text(hjust = 0.5, 
                                  margin = margin(t = 5, r = 0, b = 0, l = 100))) +
  ggplot2::scale_fill_manual(values= omics.colors)
```


# Gaussian kernel
## ConsensusOPLS-DA model

```{r run_model_da_kernel3}
# rvcopls <- ConsensusOPLS:::ConsensusOPLS(data = omics.common.data2,
#                                          Y=factor(Y),
#                                          maxPcomp = LVsPred,
#                                          maxOcomp  = LVsOrtho,
#                                          modelType = "da",
#                                          nperm = 2,
#                                          cvType = "nfold",
#                                          nfold = CVfolds,
#                                          kernelParams = 
#                                            list(type = "g", 
#                                                 params = c(order = 1)),
#                                          mc.cores = 1,
#                                          verbose = TRUE)
```

```{r print_main_results_R2_kernel3, class.source='fold-hide'}
# Optimal_model_no_perm <- rvcopls$optimal
# position <- rvcopls@nOcompOpt+1
# 
# paste0('R2: ', round(rvcopls@R2Yhat[position], 4))
```

```{r print_main_results_Q2_kernel3, class.source='fold-hide'}
# paste0('Q2: ', round(rvcopls@Q2Yhat[position], 4))
```

```{r print_main_results_DQ2_kernel3, class.source='fold-hide'}
# paste0('DQ2: ', round(rvcopls@DQ2Yhat[position], 4))
```

```{r ggplot_score_data_kernel3, class.source='fold-hide', warning=FALSE}
# ggplot2::ggplot(data = data.frame("p_1" = rvcopls@scoresP,
#                                   "o_1" = rvcopls@scoresO,
#                                   "Labs" = as.matrix(base::unlist(rownames(omics.common.data2$Gene))),
#                                   "Factor" = gsub(pattern = "-.*",
#                                                   replacement = "",
#                                                   x = rownames(omics.common.data2$Gene))),
#                 aes(x = p_1, y = o_1, label = Labs, 
#                     shape = Factor, colour = Factor)) +
#   ggplot2::xlab("Predictive component") +
#   ggplot2::ylab("Orthogonal component") +
#   ggplot2::ggtitle("ConsensusOPLS Score plot")+
#   ggplot2::geom_point(size = 2.5) + 
#   ggrepel::geom_text_repel(size = 4, show.legend = FALSE) + 
#   theme_graphs+
#   ggplot2::scale_color_manual(values = c("#7F3C8D", "#11A579"))
```

## ConsensusOPLS-reg log model

```{r run_model_reg_kernel3}
# rvcopls.reg <- ConsensusOPLS:::ConsensusOPLS(data = omics.common.data2,
#                                              Y=factor(Y),
#                                              maxPcomp = LVsPred,
#                                              maxOcomp  = LVsOrtho,
#                                              modelType = "reg",
#                                              nperm = 2,
#                                              cvType = "nfold",
#                                              nfold = CVfolds, 
#                                              kernelParams = 
#                                                list(type = "g", 
#                                                     params = c(order = 1)),
#                                              mc.cores = 1,
#                                              verbose = TRUE)

#Y=omics.common[['all']][["Survival"]][id2,'Survival'],
```


```{r print_main2_results_R2_kernel3, class.source='fold-hide'}
# Optimal_model_no_perm <- rvcopls.reg$optimal
# position <- rvcopls@nOcompOpt+1
# 
```

```{r print_main2_results_Q2_kernel3, class.source='fold-hide'}
# paste0('Q2: ', round(rvcopls@Q2Yhat[position], 4))
```

```{r ggplot2_score_data_kernel3, class.source='fold-hide', warning=FALSE}
# ggplot2::ggplot(data = data.frame("p_1" = rvcopls@scoresP,
#                                   "o_1" = rvcopls@scoresO,
#                                   "Labs" = as.matrix(base::unlist(rownames(omics.common.data2$Gene))),
#                                   "Factor" = gsub(pattern = "-.*",
#                                                   replacement = "",
#                                                   x = rownames(omics.common.data2$Gene))),
#                 aes(x = p_1, y = o_1, label = Labs, 
#                     shape = Factor, colour = Factor)) +
#   ggplot2::xlab("Predictive component") +
#   ggplot2::ylab("Orthogonal component") +
#   ggplot2::ggtitle("ConsensusOPLS Score plot")+
#   ggplot2::geom_point(size = 2.5) + 
#   ggrepel::geom_text_repel(size = 4, show.legend = FALSE) + 
#   theme_graphs+
#   ggplot2::scale_color_manual(values = c("#7F3C8D", "#11A579"))
```





# Parallelisation on windows

In the last part of this document, we can evaluate the execution time of the 
different models, depending on the number of cores used for parallelisation.
As an example, let's take a model with 1000 permutations:

```{r test_parallelisation_100}
# CVfolds <- round(sqrt(CVfolds), 0)
# CVfolds
# 
# cores_max <- detectCores()
# cores_max
# 
# lapply(X = c(1:cores_max),
#        FUN = function(cores_tested){
#          print(paste0("cores_tested = ", cores_tested))
#          Tstart<-Sys.time()
#          ConsensusOPLS::ConsensusOPLS(data = omics.common.data2,
#                                       Y=factor(Y),
#                                       maxPcomp = LVsPred,
#                                       maxOcomp  = LVsOrtho,
#                                       modelType = "da",
#                                       nperm = 100,
#                                       cvType = "nfold",
#                                       nfold = CVfolds,
#                                       kernelParams =
#                                         list(type = "p",
#                                              params = c(order = 2)),
#                                       mc.cores = cores_tested,
#                                       verbose = TRUE)
#          Tend<-Sys.time()
#          Tellapsed <- Tend - Tstart
#          return(Tellapsed)
#        })
```

And now, let's take a model with 1000 permutations:

```{r test_parallelisation_1000}
# lapply(X = c(1:cores_max),
#        FUN = function(cores_tested){
#          print(paste0("cores_tested = ", cores_tested))
#          Tstart<-Sys.time()
#          ConsensusOPLS::ConsensusOPLS(data = omics.common.data2,
#                                       Y=factor(Y),
#                                       maxPcomp = LVsPred,
#                                       maxOcomp  = LVsOrtho,
#                                       modelType = "da",
#                                       nperm = 1000,
#                                       cvType = "nfold",
#                                       nfold = CVfolds,
#                                       kernelParams =
#                                         list(type = "p",
#                                              params = c(order = 2)),
#                                       mc.cores = cores_tested,
#                                       verbose = TRUE)
#          Tend<-Sys.time()
#          Tellapsed <- Tend - Tstart
#          return(Tellapsed)
#        })
```





# Reproducibility

Here is the output of `sessionInfo()` on the system on which this document was 
compiled:

```{r reproducibility}
sessionInfo()
```

# References
